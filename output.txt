#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use crate::io::{expected_read, open_file};
use crate::lexer::{StateMachine, Token};
/// Handler of all IO related functionality.
mod io {
    use std::{
        env::args, fs::File, io::{Bytes, Read},
        sync::LazyLock,
    };
    use crate::error_codes::{BYTE_READ_ERROR, CLI_PARSE_ERROR, OPEN_FILE_ERROR};
    /// The input path passed-in from the CLI arguments, which is always expected.
    ///
    /// This is purposely left private to compartmentalize the IO module.
    ///
    /// LazyLock ensures that the value is loaded in static run-time memory
    /// when first accessed, and ensures that the value is never mutated.
    static INPUT_PATH: LazyLock<String> = LazyLock::new(|| {
        let found_argument = args()
            .enumerate()
            .find(|(_index, c)| c == "-i")
            .map(|(index, _c)| index);
        if found_argument.is_none() {
            {
                ::std::io::_eprint(
                    format_args!("ERROR - provide argument `-i` to input a file\n"),
                );
            };
            std::process::exit(CLI_PARSE_ERROR)
        }
        let input_arg_index = found_argument.unwrap() + 1;
        let found_path = args().skip(input_arg_index).next();
        if found_path.is_none() {
            {
                ::std::io::_eprint(
                    format_args!(
                        "ERROR - please provide input file after argument `-i`\n",
                    ),
                );
            };
            std::process::exit(CLI_PARSE_ERROR)
        }
        let input_file_path = found_path.unwrap();
        return input_file_path;
    });
    /// Returns an interator over the bytes of a file.
    ///
    /// The program will exit with an error message if the file cannot be opened.
    pub fn open_file() -> Bytes<File> {
        match File::open(INPUT_PATH.as_str()) {
            Ok(file) => file.bytes(),
            Err(err) => {
                {
                    ::std::io::_eprint(
                        format_args!(
                            "ERROR - could not open file `{0}` due to IO error - `{1}`\n",
                            INPUT_PATH.as_str(),
                            err,
                        ),
                    );
                };
                std::process::exit(OPEN_FILE_ERROR)
            }
        }
    }
    /// Helper unwrapping function for an IO read of a byte.
    ///
    /// If the input is `None`, the program exits with an error message.
    /// Otherwise, the input is `Some(_)` and we safely unwrap the Result.
    pub fn expected_read(maybe_c: Result<u8, std::io::Error>) -> u8 {
        maybe_c
            .map_err(|err| {
                {
                    ::std::io::_print(
                        format_args!(
                            "ERROR - while reading byte at `{0}` due to IO error - `{1}`\n",
                            INPUT_PATH.as_str(),
                            err,
                        ),
                    );
                };
                std::process::exit(BYTE_READ_ERROR)
            })
            .unwrap()
    }
}
/// Module for all lexical analysis types, implementations,
/// and the **lexical state machine**.
pub mod lexer {
    use crate::error_codes::LEXICAL_ERROR;
    /// The cream-of-the-crop (it always rises to the top) of this
    /// assignment: the Token enum. This token tags a lexeme for the
    /// syntactical analysis.
    pub enum Token {
        LiteralInt,
        LiteralFloat,
        Identifier,
        #[allow(dead_code)]
        Symbol(Symbol),
        #[allow(dead_code)]
        Type(Type),
        Return,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Token {
        #[inline]
        fn clone(&self) -> Token {
            let _: ::core::clone::AssertParamIsClone<Symbol>;
            let _: ::core::clone::AssertParamIsClone<Type>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Token {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Token {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Token::LiteralInt => ::core::fmt::Formatter::write_str(f, "LiteralInt"),
                Token::LiteralFloat => {
                    ::core::fmt::Formatter::write_str(f, "LiteralFloat")
                }
                Token::Identifier => ::core::fmt::Formatter::write_str(f, "Identifier"),
                Token::Symbol(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Symbol",
                        &__self_0,
                    )
                }
                Token::Type(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Type",
                        &__self_0,
                    )
                }
                Token::Return => ::core::fmt::Formatter::write_str(f, "Return"),
            }
        }
    }
    impl From<Symbol> for Token {
        fn from(sym: Symbol) -> Self {
            Token::Symbol(sym)
        }
    }
    impl From<Type> for Token {
        fn from(ty: Type) -> Self {
            Token::Type(ty)
        }
    }
    /// All the singleton character parseable symbols.
    ///
    /// This includes
    /// - Arithmetic Operators
    /// - Assignment Operators
    /// - Grouping Operators
    /// - Identifier Underscore
    /// - Comma/Period
    pub enum Symbol {
        Plus,
        Minus,
        Multiply,
        Divide,
        Equal,
        Semicolon,
        LeftParen,
        RightParen,
        LeftCurly,
        RightCurly,
        Underscore,
        Comma,
        Period,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Symbol {
        #[inline]
        fn clone(&self) -> Symbol {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Symbol {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Symbol {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Symbol::Plus => "Plus",
                    Symbol::Minus => "Minus",
                    Symbol::Multiply => "Multiply",
                    Symbol::Divide => "Divide",
                    Symbol::Equal => "Equal",
                    Symbol::Semicolon => "Semicolon",
                    Symbol::LeftParen => "LeftParen",
                    Symbol::RightParen => "RightParen",
                    Symbol::LeftCurly => "LeftCurly",
                    Symbol::RightCurly => "RightCurly",
                    Symbol::Underscore => "Underscore",
                    Symbol::Comma => "Comma",
                    Symbol::Period => "Period",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Symbol {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Symbol {
        #[inline]
        fn eq(&self, other: &Symbol) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Symbol {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    /// A determinant of a grouping of a character.
    enum CharClass {
        /// [a-zA-Z]
        Letter,
        /// [0-9]
        Digit,
        /// [+-*/=;(){}_,.]
        Symbol(Symbol),
        /// An unexpected character was parsed...
        Unknown,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CharClass {
        #[inline]
        fn clone(&self) -> CharClass {
            let _: ::core::clone::AssertParamIsClone<Symbol>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for CharClass {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for CharClass {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for CharClass {
        #[inline]
        fn eq(&self, other: &CharClass) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (CharClass::Symbol(__self_0), CharClass::Symbol(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for CharClass {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Symbol>;
        }
    }
    impl CharClass {
        /// Parses a byte, expecting a 7-bit ascii code.
        pub fn parse(c: u8) -> Self {
            if c < 0x21 || 0x7E < c {
                return Self::Unknown;
            }
            match c as char {
                'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l'
                | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x'
                | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J'
                | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V'
                | 'W' | 'X' | 'Y' | 'Z' => Self::Letter,
                '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => Self::Digit,
                '+' => Symbol::Plus.into(),
                '-' => Symbol::Minus.into(),
                '*' => Symbol::Multiply.into(),
                '/' => Symbol::Divide.into(),
                '=' => Symbol::Equal.into(),
                ';' => Symbol::Semicolon.into(),
                '(' => Symbol::LeftParen.into(),
                ')' => Symbol::RightParen.into(),
                '{' => Symbol::LeftCurly.into(),
                '}' => Symbol::RightCurly.into(),
                '_' => Symbol::Underscore.into(),
                ',' => Symbol::Comma.into(),
                '.' => Symbol::Period.into(),
                _ => Self::Unknown,
            }
        }
    }
    impl From<Symbol> for CharClass {
        fn from(sym: Symbol) -> Self {
            CharClass::Symbol(sym)
        }
    }
    /// A type keyword.
    pub enum Type {
        Int,
        Float,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Type {
        #[inline]
        fn clone(&self) -> Type {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Type {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Type {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Type::Int => "Int",
                    Type::Float => "Float",
                },
            )
        }
    }
    /// Returns `true` for any ascii whitespace characters.
    fn is_whitespace(c: u8) -> bool {
        match c {
            0x9 | 0xA | 0xB | 0xC | 0xD | 0x20 => true,
            _ => false,
        }
    }
    /// Compares a character literal and an 8-bit byte for equality.
    fn matches(control: char, test: u8) -> bool {
        (control as u32) == (test as u32)
    }
    /// Exhaustively, all possible states of the state machine.
    ///
    /// ### Note
    /// For special keywords like
    /// - `int`
    /// - `float`
    /// - `return`
    ///
    /// there are *n* unique states, with *n* being the number
    /// of characters in a keyword.
    ///
    /// This is due to the keywords using the same
    /// characters as identifiers, hence the reason
    /// each one of these special states fail-safe
    /// the state back to an identifier.
    enum State {
        /// Countinue to skip whitespace characters until a non-whitespace is selected.
        /// When a non-whitespace character is encountered, depatch to the next state.
        ScrollToNext,
        /// Expecting a decimal literal.
        /// This can be promoted to NumberFloat if '.' is encountered later on.
        NumberDigit,
        /// Parsing the decimal part of the floating point number.
        NumberFloat,
        /// Expecting an identifier.
        /// This happens after other word possibilities (types/keywords) have been ruled out.
        Identifier,
        /// A word that is possibly the `int` keyword.
        /// Test the second letter for 'n'.
        /// If passed, go on to test the third letter, defaulting to identifier.
        MaybeTypeInt2,
        /// A word that is possibly the `int` keyword.
        /// Test the third letter for 't'.
        /// If passed, go on to test to confirm, defaulting to identifier.
        MaybeTypeInt3,
        /// Test that the lexeme is, in fact, the int keyword depending on the given byte.
        /// Only if it is a letter, underscore, or digit, it will not confirm.
        ConfirmTypeInt,
        /// A word that is possibly the `float` keyword.
        /// Test the second letter for 'l'.
        /// If passed, go on to test the third letter, defaulting to identifier.
        MaybeTypeFloat2,
        /// A word that is possibly the `float` keyword.
        /// Test the third letter for 'o'.
        /// If passed, go on to test the fourth letter, defaulting to identifier.
        MaybeTypeFloat3,
        /// A word that is possibly the `float` keyword.
        /// Test the fourth letter for 'a'.
        /// If passed, go on to test the fifth letter, defaulting to identifier.
        MaybeTypeFloat4,
        /// A word that is possibly the `float` keyword.
        /// Test the fifth letter for 't'.
        /// If passed, go on to test to confirm, defaulting to identifier.
        MaybeTypeFloat5,
        /// Test that the lexeme is, in fact, the float keyword depending on the given byte.
        /// Only if it is a letter, underscore, or digit, it will not confirm.
        ConfirmTypeFloat,
        /// A word that is possibly the `return` keyword.
        MaybeKeywordReturn2,
        /// A word that is possibly the `return` keyword.
        MaybeKeywordReturn3,
        /// A word that is possibly the `return` keyword.
        MaybeKeywordReturn4,
        /// A word that is possibly the `return` keyword.
        MaybeKeywordReturn5,
        /// A word that is possibly the `return` keyword.
        MaybeKeywordReturn6,
        /// A word that is possibly the `return` keyword.
        ConfirmKeywordReturn,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for State {
        #[inline]
        fn clone(&self) -> State {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for State {}
    /// The core structure of the lexical analysis.
    /// This simply stores the current state,
    /// and a string buffer for the constructing lexeme.
    ///
    /// The main method of this struct is the `tick` method,
    /// which takes in a byte as input, causing the state machine to
    /// advance, and then may return 0, 1, or 2 token-lexeme pairs, depending on the
    /// given input and the current state of the machine.
    ///
    /// 0. 0 tokens implies either a whitespace character was passed in while
    /// ignoring whitespaces, or the character was purely concatenated into the
    /// internal lexeme buffer.
    /// 1. 1 token implies that a non-symbol byte was passed in, which also completed the lexeme.
    /// 2. 2 tokens implies that symbol byte was passed in (which completes immediately),
    /// which forces the current lexeme to also flush to preserve token-lexeme order.
    pub(crate) struct StateMachine {
        state: State,
        lexeme: String,
    }
    impl StateMachine {
        /// Hard resets the state machine,
        /// erasing the lexeme and going into its default state
        fn reset(&mut self) {
            self.state = State::ScrollToNext;
            self.lexeme.truncate(0);
        }
        /// Report an error with a given error message, and exit the program.
        fn detonate(&self, err_msg: String) -> ! {
            {
                ::std::io::_eprint(
                    format_args!("ERROR - failed to parse lexemes: {0}\n", err_msg),
                );
            };
            std::process::exit(LEXICAL_ERROR)
        }
        /// Creates a new state machine for lexical analysis.
        ///
        /// The starting state is expecting 0 or more whitespace,
        /// with an empty lexeme buffer.
        pub fn new() -> Self {
            Self {
                state: State::ScrollToNext,
                lexeme: "".into(),
            }
        }
        /// Completes the state machine, outputting a lexeme if one exists.
        ///
        /// This is useful to use once EOF has been reached from the input source.
        ///
        /// This function is identical to matching a whitespace.
        pub fn finalize(mut self) -> Option<Vec<(Token, String)>> {
            self.tick(0xA)
        }
        /// # Description
        ///
        /// Advances the state machine by a singular byte,
        /// updating the internal state of the state machine.
        ///
        /// If one or more lexemes have been detected as complete,
        /// this function will return `Some`.
        /// Otherwise, this will return `None`.
        ///
        /// It is the user's responsibility to know when the input has ended, and
        /// then use `finalize`.
        ///
        /// ## Special notes to the grader...
        ///
        /// This function defines 3 macros, meant to greatly reduce boilerplate code
        /// of a repeating design pattern, written only for the scope of `tick`. This
        /// is intended to make the code more readable and maintainable.
        ///
        /// This is important to mention, because this function
        /// returns `Some(_)` rather than `None` if and only if
        ///
        /// 1. It was called through 1 of the 3 macros, and
        /// 2. The state machine was reset.
        ///
        /// Hense, the verbage of "flush" in each of the macros.
        ///
        /// Each of the three macros are documented in source code.
        pub fn tick(&mut self, c: u8) -> Option<Vec<(Token, String)>> {
            use crate::lexer::Symbol as Sym;
            use CharClass::*;
            use Type as Ty;
            match self.state {
                State::ScrollToNext if is_whitespace(c) => None,
                State::ScrollToNext => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('i', c) => State::MaybeTypeInt2,
                        Letter if matches('f', c) => State::MaybeTypeFloat2,
                        Letter if matches('r', c) => State::MaybeKeywordReturn2,
                        Letter | Symbol(Sym::Underscore) => State::Identifier,
                        Digit => State::NumberDigit,
                        Symbol(sym) => {
                            let output = (sym.into(), { c as char }.into());
                            self.reset();
                            return Some(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([output]),
                                ),
                            );
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!("Unknown character `0x{0:x}`", c),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::NumberDigit if is_whitespace(c) => {
                    let output = (Token::LiteralInt, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::NumberDigit => {
                    self
                        .state = match CharClass::parse(c) {
                        Digit => State::NumberDigit,
                        Symbol(Sym::Period) => State::NumberFloat,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::LiteralInt, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        _ => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::NumberFloat if is_whitespace(c) => {
                    let output = (Token::LiteralFloat, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::NumberFloat => {
                    self
                        .state = match CharClass::parse(c) {
                        Digit => State::NumberDigit,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::LiteralFloat, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        _ => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::Identifier if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::Identifier => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            {
                                let mut output = <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([
                                        (Token::Identifier, self.lexeme.clone()),
                                    ]),
                                );
                                output.push(({ sym }.into(), { c as char }.into()));
                                self.reset();
                                return Some(output);
                            };
                        }
                        _ => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeTypeInt2 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeTypeInt2 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('n', c) => State::MaybeTypeInt3,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeTypeInt3 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeTypeInt3 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('t', c) => State::ConfirmTypeInt,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::ConfirmTypeInt if is_whitespace(c) => {
                    let output = (Ty::Int.into(), self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::ConfirmTypeInt => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeTypeFloat2 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeTypeFloat2 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('l', c) => State::MaybeTypeFloat3,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeTypeFloat3 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeTypeFloat3 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('o', c) => State::MaybeTypeFloat4,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeTypeFloat4 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeTypeFloat4 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('a', c) => State::MaybeTypeFloat5,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeTypeFloat5 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeTypeFloat5 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('t', c) => State::ConfirmTypeFloat,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::ConfirmTypeFloat if is_whitespace(c) => {
                    let output = (Ty::Float.into(), self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::ConfirmTypeFloat => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeKeywordReturn2 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeKeywordReturn2 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('e', c) => State::MaybeKeywordReturn3,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeKeywordReturn3 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeKeywordReturn3 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('t', c) => State::MaybeKeywordReturn4,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeKeywordReturn4 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeKeywordReturn4 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('u', c) => State::MaybeKeywordReturn5,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeKeywordReturn5 if is_whitespace(c) => {
                    let output = (Token::Identifier, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeKeywordReturn5 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('r', c) => State::MaybeKeywordReturn6,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::MaybeKeywordReturn6 if is_whitespace(c) => {
                    let output = (Token::Return, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::MaybeKeywordReturn6 => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter if matches('n', c) => State::ConfirmKeywordReturn,
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
                State::ConfirmKeywordReturn if is_whitespace(c) => {
                    let output = (Token::Return, self.lexeme.clone());
                    self.reset();
                    return Some(
                        <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([output])),
                    );
                }
                State::ConfirmKeywordReturn => {
                    self
                        .state = match CharClass::parse(c) {
                        Letter | Symbol(Sym::Underscore) | Digit => State::Identifier,
                        Symbol(sym) => {
                            let mut output = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    (Token::Identifier, self.lexeme.clone()),
                                ]),
                            );
                            output.push(({ sym }.into(), { c as char }.into()));
                            self.reset();
                            return Some(output);
                        }
                        Unknown => {
                            self.detonate({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "Unexpected character `0x{1:x}` after `{0}`",
                                        self.lexeme,
                                        c,
                                    ),
                                );
                                res
                            })
                        }
                    };
                    self.lexeme.push(c as char);
                    None
                }
            }
        }
    }
}
/// Orangized storage of the unique error codes.
mod error_codes {
    /// There was a problem while parsing the passed-in arguments to the program.
    pub(crate) const CLI_PARSE_ERROR: i32 = 1;
    /// There was an IO problem opening the file.
    pub(crate) const OPEN_FILE_ERROR: i32 = 2;
    /// Encountered an error while reading the file.
    pub(crate) const BYTE_READ_ERROR: i32 = 3;
    /// There was a parse error in the program.
    pub(crate) const LEXICAL_ERROR: i32 = 4;
}
/// Opens the file, then builds the tokens/lexemes
/// from a state machine byte-by-byte
/// in 1 pass, in order.
///
/// Returns the constructed token-lexeme pairs in order.
pub fn get_lexemes() -> Vec<(Token, String)> {
    let source = open_file();
    let mut lexer_state_machine = StateMachine::new();
    let mut lexemes = source
        .map(|maybe_c| expected_read(maybe_c))
        .filter_map(|byte: u8| lexer_state_machine.tick(byte))
        .flatten()
        .collect::<Vec<_>>();
    if let Some(final_tokens) = lexer_state_machine.finalize() {
        lexemes.extend(final_tokens);
    }
    lexemes
}
